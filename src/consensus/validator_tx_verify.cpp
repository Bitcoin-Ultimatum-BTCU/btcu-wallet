// Copyright (c) 2009-2010 Satoshi Nakamoto
// Copyright (c) 2009-2014 The Bitcoin developers
// Copyright (c) 2015-2019 The BTCU developers
// Distributed under the MIT software license, see the accompanying
// file COPYING or http://www.opensource.org/licenses/mit-license.php.

#include <masternode.h>
#include "main.h"
#include "validator_tx_verify.h"


bool IsUtxoDestination(const CPubKey &pubKey, const CTxOut &vout)
{
    CTxDestination pubkeyAddress(pubKey.GetID());
    CTxDestination outputAddress;
    ExtractDestination(vout.scriptPubKey, outputAddress);
    
    return (pubkeyAddress == outputAddress);
}

// Check output with index n
bool CheckVinCoin(const CCoins *coins, uint32_t n, const CPubKey &pubKey)
{
    if (coins)
    {
        if(coins->vout[n].nValue == COIN * MN_DEPOSIT_SIZE &&
           IsUtxoDestination(pubKey, coins->vout[n]))
        {
            return true;
        }
    }
    return false;
}

int GetCoinsAge(const CCoins *coins)
{
    int coinsAge = -1;
    if (coins)
    {
        if (coins->nHeight < 0){
            coinsAge = 0;
        } else {
            coinsAge = ((chainActive.Tip()->nHeight + 1) - coins->nHeight);
        }
    }
    return coinsAge;
}

// Checking that:  - input is unspent and has sufficient confirmations number;
//                 - public key is the same as specified in VIN's UTXO (thus any signature generated with such a public key is generated by the VIN's owner)
bool CheckCredentials(const CTxIn &vin, CPubKey &pubKey, const CCoinsViewCache &view)
{
    bool status = false;
    
    // returns coins of transation with 'vin.prevout.hash' id
    const CCoins* unspentCoins = view.AccessCoins(vin.prevout.hash);
    if (unspentCoins)
    {
        status = (CheckVinCoin(unspentCoins, vin.prevout.n, pubKey) &&
                  GetCoinsAge(unspentCoins) >= MASTERNODE_MIN_CONFIRMATIONS);
    }
    return status;
}

// Validation of the validator-registration part of transaction if it is present
bool CheckValidatorRegister(const CTransaction &tx, const CCoinsViewCache &view, int nHeight)
{
    bool status = false;
    int currentPositionInVotingPeriod = nHeight % VALIDATORS_VOTING_PERIOD_LENGTH;
    
    // Checking that transaction is received during corresponding phase of the current voting period
    if((currentPositionInVotingPeriod >= VALIDATORS_REGISTER_START) &&
       (currentPositionInVotingPeriod <= VALIDATORS_REGISTER_END))
    {
        if (!tx.validatorRegister.empty())
        {
            auto valReg = tx.validatorRegister.front();
            
            status = (CheckCredentials(valReg.vin, valReg.pubKey, view) &&
                      valReg.Verify(valReg.pubKey)); //  CValidatorRegister's signature verification
        }
    }
    return status;
}

bool CandidateIsRegistered(const CTxIn &vin)
{
    auto validatorsRegistrationList = g_ValidatorsState.get_registrations();
    
    auto is_vin = [vin](CValidatorRegister valReg) -> bool {
        return (valReg.vin == vin);
    };
    return (std::find_if(validatorsRegistrationList.begin(), validatorsRegistrationList.end(), is_vin) != validatorsRegistrationList.end());
}

bool VotesAreValid(const std::vector<MNVote> &votes)
{
    auto status = !votes.empty();
    for(auto &v : votes)
    {
        // should be one of possible options
        if(v.vote != VoteAbstain && v.vote != VoteYes && v.vote != VoteNo){
            status = false;
            break;
        }
        // vote should be for an already registered candidate
        if(!CandidateIsRegistered(v.vin)){
            status = false;
            break;
        }
        // TODO: check also by the list of approved validators
    }
    return status;
}

// Validation of the validator-registration part of transaction if it is present
bool CheckValidatorVote(const CTransaction &tx, const CCoinsViewCache &view, int nHeight)
{
    bool status = false;
    int currentPositionInVotingPeriod = nHeight % VALIDATORS_VOTING_PERIOD_LENGTH;
    
    // Checking that transaction is received during corresponding phase of the current voting period
    if((currentPositionInVotingPeriod >= VALIDATORS_VOTING_START) &&
       (currentPositionInVotingPeriod <= VALIDATORS_VOTING_END))
    {
        if (!tx.validatorVote.empty())
        {
            auto valVote = tx.validatorVote.front();
            
            status = (CheckCredentials(valVote.vin, valVote.pubKey, view) &&
                      valVote.Verify(valVote.pubKey) &&
                      VotesAreValid(valVote.votes)); //  CValidatorVote's signature verification
        }
    }
    return status;
}

bool AlreadyRegistered(const CTransaction &tx)
{
    auto validatorsRegistrationList = g_ValidatorsState.get_registrations();
    
    for(auto &valReg : validatorsRegistrationList)
    {
        // public key corresponds to VIN, so also can be used for MN identification
        if(valReg.pubKey == tx.validatorRegister.front().pubKey){
            return true;
        }
    }
    return false;
}

bool AlreadyVoted(const CTransaction &tx)
{
    auto validatorsVotesList = g_ValidatorsState.get_votes();
    
    for(auto &valVote : validatorsVotesList)
    {
        // public key corresponds to VIN, so also can be used for MN identification
        if(valVote.pubKey == tx.validatorVote.front().pubKey){
            return true;
        }
    }
    return false;
}

bool AlreadyPresent(const CTransaction &tx, std::vector<CTransaction> &validatorTransactionsInCurrentBlock)
{
    for(auto &presentTx : validatorTransactionsInCurrentBlock)
    {
        if(tx.IsValidatorRegister() && presentTx.IsValidatorRegister()){
            if(tx.validatorRegister.front().vin == presentTx.validatorRegister.front().vin){
                return true;
            }
        }
        if(tx.IsValidatorVote() && presentTx.IsValidatorVote()){
            if(tx.validatorVote.front().vin == presentTx.validatorVote.front().vin){
                return true;
            }
        }
    }
    return false;
}

// Checks fot validator-related transactions
bool CheckValidatorTransaction(
        const CTransaction &tx,
        CValidationState &state,
        const CCoinsViewCache &view,
        int nHeight,
        std::vector<CTransaction> &validatorTransactionsInCurrentBlock)
{
    if (tx.IsValidatorRegister() && tx.IsValidatorVote())
    {
        return state.DoS(10, error("CheckValidatorTransaction() : check failed"),
                         REJECT_INVALID, "validator-register-and-vote");
    }
    // Check that transaction from the same MN wasn't included into a current block
    if(AlreadyPresent(tx, validatorTransactionsInCurrentBlock))
    {
        return state.DoS(10, error("CheckValidatorTransaction() : check failed"),
                         REJECT_INVALID, "duplicated-validator-transaction");
    } else {
        if (tx.IsValidatorRegister())
        {
            if(!CheckValidatorRegister(tx, view, nHeight) || AlreadyRegistered(tx))
            {
                return state.DoS(10, error("CheckValidatorTransaction() : check failed"),
                                 REJECT_INVALID, "bad-validator-register");
            }
        }
        else if (tx.IsValidatorVote())
        {
            if(!CheckValidatorVote(tx, view, nHeight) || AlreadyVoted(tx))
            {
                return state.DoS(10, error("CheckValidatorTransaction() : check failed"),
                                 REJECT_INVALID, "bad-validator-vote");
            }
        }
        return true;
    }
}
